## 9. API 디자인 발전시키기

*"규격을 바꿔 기존 사용자들이 사용할 수 없게 만드는 것을 브레이킹 체인지라고 한다."*



이 장의 내용

- 브레이킹 체인지를 유발하지 않고 API 발전시키기
- 브레이킹 체인지를 관리하기 위해 API에 버전 지정하기
- 브레이킹 체인지를 유발하지 않는 확장가능한 API 디자인하기



API에도 마찬가지로 브레이킹 체인지는 필연적으로 발생한다. 어떻게 브레이킹 체인지를 감당하며 진화하는 디자인을 만들 수 있는지 알아보도록 하자.



### 9.1 API 진화 디자인

#### 9.1.1 출력 데이터의 브레이킹 체인지 회피하기

분명 더 좋은 디자인의 API로 변경한 것일 수 있으나 컨슈머에게는 큰 영향을 끼칠 수 있다.



출력 데이터에 적용하는 브레이킹 체인지에 따른 결과

| 변경                                                  | 결과                                                         |
| ----------------------------------------------------- | ------------------------------------------------------------ |
| 속성 이름 변경<br />(amt -> amount)                   | 구현에 따라 다름 (UI에서 데이터 사라짐, 데이터 오염, 충돌 등) |
| 속성 위치 이동<br />(merchantZip -> merchant.zip)     | 구현에 따라 다름 (UI에서 데이터 사라짐, 데이터 오염, 충돌 등) |
| 필수 속성 제거<br />(aboveAverageAmount 속성 제거)    | 구현에 따라 다름 (UI에서 데이터 사라짐, 데이터 오염, 충돌 등) |
| 필수 속성에서 선택 사항으로 변경                      | 구현에 따라 다름 (UI에서 데이터 사라짐, 데이터 오염, 충돌 등) |
| 속성 타입 변경<br />(1, 2 -> CARD, WITHDRAWAL)        | 파싱 에러                                                    |
| 속성 포맷 변경<br />(Unix timestamp -> ISO 8601 date) | 파싱 에러                                                    |
| 속성 특징 변경 (길이, 숫자 범위, 배열 요소 길이 확장) | 구현에 따라 다름 (UI에서 데이터 사라짐, 데이터 오염, 충돌 등) |
| 속성 의미 변경                                        | 최악의 결과 (치명적이고 교묘하다)                            |
| enum 값 추가                                          | 구현에 따라 다름 (UI에서 데이터 사라짐, 데이터 오염, 충돌 등) |



#### 9.1.2 입력데이터와 파라미터에서 브레이킹 체인지 회피하기



입력 데이터에 적용하는 브레이킹 체인지에 따른 결과

| 변경                                                  | 결과                              | 출력 데이터에 적용했을 때와 비교                    |
| ----------------------------------------------------- | --------------------------------- | --------------------------------------------------- |
| 속성 이름 변경<br />(amt -> amount)                   | API 에러                          | 동일                                                |
| 속성 위치 이동<br />(merchantZip -> merchant.zip)     | API 에러                          | 동일                                                |
| 필수 속성 제거<br />(aboveAverageAmount 속성 제거)    | API 에러                          | 동일                                                |
| 선택 사항에서 필수 속성으로 변경                      | API 에러                          | 반대 (필수 속성을 선택 사항으로 변경했을 때와 동일) |
| 속성 타입 변경<br />(1, 2 -> CARD, WITHDRAWAL)        | API 에러                          | 동일                                                |
| 속성 포맷 변경<br />(Unix timestamp -> ISO 8601 date) | API 에러                          | 동일                                                |
| 속성 특징 변경 (길이, 숫자 범위, 배열 요소 길이 확장) | API 에러                          | 반대 (특징을 확장한 때와 동일)                      |
| 속성 의미 변경                                        | 최악의 결과 (치명적이고 교묘하다) | 반대 (컨슈머 영역에 영향을 미침)                    |
| enum 값 제거                                          | API 에러                          | 반대 (값을 추가할 때와 같음)                        |
| 필수 속성 추가                                        | API 에러                          | 에러 발생 안함 (브레이킹 체인지가 아님)             |



#### 9.1.3 성공과 에러 피드백에서 브레이킹 체인지 회피하기

에러 피드백을 고치는 건 심각한 브레이킹 체인지가 생길 수 있다.

- ex) items 안에 에러 피드백 -> errors 안에 에러 피드백으로 수정



"명시적인 상태 코드가 존재할지라도, HTTP 클라이언트는 모든 상태 코드를 알 필요가 없습니다. 그렇지만 클라이언트들은 반드시 그 상태 코드의 첫 글자를 이용해서 클래스를 알아야 하며, 이를 통해 식별되지 않는 상태 코드라도 X00이라는 상태 코드와 동일하게 취급해야합니다."

RFC 7231



컨슈머는 문서에만 충실하지말고 RFC를 충족하는 것이 더 좋다. 그렇다고 프로바이더가 RFC 7231을 기대하고 만드는건 확장성을 떨어뜨리는 것이다.



#### 9.1.4 목표와 흐름에서 브레이킹 체인지 회피하기

목표에서 브레이킹 체인지가 발생할 수 있다. 

- 이름 변경
  - 301 Moved Permanently HTTP 상태코드를 주어 리디렉션 시킬 수 있다.
  - 컨슈머가 불편할 수 있음
- 목표 제거
  - 405 Method Not Allowed

- 목표 추가
  - 다른 목표에 영향을 주면 **사일런트 브레이킹 체인지** (에러가 없어서 문제가 발생한 줄 모름)이 발생할 수 있다.



#### 9.1.5 브레이킹 체인지의 보안 취약점 발생 회피하기

- 토큰에 첨부되던 데이터가 변경되거나 사라지면 심각한 결과 초래
  - ex) 토큰에 최종 사용자 ID 제거
    - 이는 관리자 타입이라고 생각하는 컨슈머가 있을수도 있다.



#### 9.1.6 보이지 않는 인터페이스 컨트랙트에 주의하기

#### 9.1.7 브레이킹 체인지를 유발하는 것이 항상 문제는 아닙니다.

컨텍스트에 따라 모든 소비자가 API를 사용하여 동기적 업데이트를 할 수 있다면 도입해도 문제가 되지 않을 것이다. 하지만 이는 생각보다 쉽지 않을 것이다. 

이를 위한 해결 법에는 API 버전이 있다.



___

### 9.2 API 버전 정하기

*"API 버전 관리는 디자인 외에도 세부구현과 제품 관리에 영향을 미친다."*



#### 9.2.1 API 버전 관리와 구현 버전 관리 비교

#### 9.2.2 컨슈머 관점에서 API 버전 표현 선택하기

도메인, 패스~



#### 9.2.3 API 버저닝의 세분화 정하기

API 버저닝 세분화 선택

| 세분화 정도   | 장점                                                       | 단점                                                         | 추천 여부                                                    |
| ------------- | ---------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| API           | 어떠한 버전의 동작이나 리소스가 함께 하는지 고민 필요 없음 | 브레이킹 체인지를 유발한 변경이 무엇인지 단서를 제공할 수 없음 | 관습적으로 REST API의 기본 세분화 전략                       |
| 리소스        | 변경에 대한 힌트를 제공                                    | 어떤 버전끼리 같이 동작하는지 알 수 없다.                    | REST API에는 추천하지 않음. 리소스가 완전히 독립적일 때만 사용 |
| 목표/동작     | 어떤 목표가 변경되었는지 표시 가능                         | 어떤 버전끼리 같이 동작하는지 추측 불가                      | REST API에는 추천하지 않음. 동작이 완전히 독립적일 때만 사용 |
| 데이터/메시지 | 어떤 데이터/메시지가 변경되었는지 표시 가능                | 데이터/메시지가 어떤 버전끼리 동작하는지 추측 불가. HTTP에서 리퀘스트/리스폰스 바디에만 유효 | REST API에는 추천하지 않음.   API 레벨 세분화 과정에서 병용할 수는 있다. |



#### 9.2.4 API 버저닝이 디자인을 넘어 미치는 영향들

*"언제나처럼 상황에 적합한 해결책을 선택하자"*



---

### 9.3 API를 디자인할 때 확장성(Extensibility)을 명심하기

#### 9.3.1 확장 가능한 데이터 디자인하기

모든 고레벨의 데이터는 반드시 오브젝트라는 봉투에 담겨 확장설을 보장하고 브레이킹 체인지의 위협을 줄여야한다.

- 그냥 아이템 배열을 전달하는 것이 아닌 items 라는 고레벨 오브젝트 내부로 넣기. 추후 totalItems 같은 값을 넣어 확장하기 편하다.
- boolean 값 대신 enum을 사용하자
  - excuted: true, validated: false 대신 status: EXECUTED 가 확장성 있다.



#### 9.3.2 확장가능한 상호작용 디자인하기

#### 9.3.3 확장 가능한 흐름 디자인하기

#### 9.3.4 확장가능한 API 디자인하기

생략