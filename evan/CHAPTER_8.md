# 3부 상황에 맞는 API 디자인

지금까지 컨슈머가 API를 사용하게 하려면 이해하기 쉽고 사용하기 쉬워야한다는 점을 인지했다. 그러나 이전까진 API를 둘러싼 전체 컨텍스트를 크게 신경쓰지 않고 디자인했다. 

다음 질문들에 대답을 해보자.

- 의도된 기능과 노출 방식을 고려하면 API의 디자인이 정말 안전한가?
- 품질 좋지 않은 3G 네트워크에서도 사용 가능한가?
- 컨슈머에게 이 디자인이 정말 최선인가?
- 다른 문서가 필요하지 않을 정도로 디자인이 좋은가?
- 이 디자인은 지금까지 만든 모든 API와 일관성을 갖는가?
- 이미 운영 환경에 출시된 API를 쉽게 수정할 수 있는가?



## 8. 안전한 API 디자인하기

*"모든 유형의 API는 보안이 중요하다."*



이 장의 내용

- API 보안
- 접근 제어를 위한 사용자 친화적 스코프 정의
- 접근 제어를 충족시키기 위한 API 디자인
- 민감한 정보를 처리하기 위한 API 디자인



### 8.1 API 보안의 개요

세 단계로 다뤄볼 것이다.

1. API 호출
   - 컨슈머 등록
   - API 소비를 허용하는 자격증명 획득
   - API 호출

2. 스코프 정의

3. 접근 제어와 민감한 데이터 관리



#### 8.1.1 컨슈머 등록하기

*"허용된 컨슈머만 API를 사용하도록 해야한다."*



1. 어드민에서 컨슈머 스코프 등록
2. 클라이언트 ID 부여



> ❓ 스코프란
>
> API에 속한 하나에서 여러 목표들을 말한다.
>
> ex) 
>
> 은행 관리자
>
> - [x] 계좌와 송금 내역을 읽는다.
>- [x] 송금한다.
> - [x] 받는 계좌를 관리한다.



#### 8.1.2 API 사용을 위해 자격증명 가져오기

일반적인 인증 처리는 다음과 같이 이루어진다.

1. 사용자 -> 클라이언트 앱 -> 인증 서버 : 인증 요청 (클라이언트 ID 포함)
2. 인증 서버 -> 클라이언트 앱 : 인증 페이지, 스코프 반환 
3. 사용자 -> 클라이언트 앱 -> 인증 서버 : 스코프와 함께 인증서버로 로그인 요청 
4. 인증 서버  : 클라이언트 ID와 스코프 확인, 인증 토큰 생성
5. 클라이언트 앱 -> 은행 리소스 서버 : 제공 받은 액세스 토큰 함께 전달

> ⚠️ 주의
>
> 컨슈머와 프로바이더 사이의 그 어떤 상호작용이라도 안전한 채널 상에서 이뤄져야한다. 
>
> HTTP 프로토콜을 이용할 경우 중간에 탈취하거나 변경할 수 없도록 전송 계층 레이어 보안(TLS: Transport Layer Security)의 암호화 (SSL: Secure Sockets Layer)로 지켜낼 수 있다.
>
> 만약 https://와 같은 주소로 시작하는 페이지를 본 적 있다면 이미 TLS를 써본 경험이 있는 것이다.



자 이제 액세스 토큰을 갖게 되었다!



#### 8.1.3 API 호출하기

1. 클라이언트 앱 -> 은행 리소스 서버 : 액세스 토큰을 가지고 계좌 목록 요청
2. 은행 리소스 서버 -> 은행 인증 서버 : 액세스 토큰 검증
3. 은행 인증 서버 -> 은행 리소스 서버 : 사용자 ID와 클라이언트 ID 그리고 스코프 반환
4. 은행 리소스 서버 -> 클라이언트 앱 : 사용자 ID를 기반으로 사용자 계좌 목록 필터링 후 전달



#### 8.1.4 보안성 관점에서 API 구상하기

*"단순히 접근제어가 있다고 해서 보안적으로 완전한 API가 아니다. 민감한 데이터를 관리해아한다."*



사용자가 계좌 목록 조회를 요청했을 때 액세스 토큰으로 스코프를 확인하고 알맞은 데이터를 필터링해서 전달했다. 하지만 이 계좌 목록에 직불 카드 정보가 들어있다면? 카드 번호, 보안 코드, 만료일, 소유자 이름 등이 제공된다면 아무리 접근제한을 했어도 안전한 API라고 볼 수 없다.

안전한 API를 만들기 위해선 접근제어 뿐 아니라 민감한 데이터를 잘 관리해야하는 것이다.



---

### 8.2 API 분할을 통한 접근 제어 활성화

*"애플리케이션에 추가되는 모든 기능은 애플리케이션 전체에 위험을 가중시킵니다. 안전을 추가하는 개발의 목표는 공격이 가능한 영역을 줄여 전체적인 위험을 줄이는 것입니다."*



최소 권한의 원칙 (컨슈머가 접근 가능한 영역을 꼭 필요한 수준으로 제한함으로서 공격에 대비한다.)을 지키기 위해 컨슈머 등록 시 최대한 적절한 스코프를 선택해야한다.



#### 8.2.1 유연하고 정제된 스코프 정의하기

모든 목표를 스코프의 요소로 제공하면 너무 복잡하기 때문에 컨셉과 액션을 이용해 제공해보자.

![image-20210618173629710](./images/image-20210618173629710.png)



#### 8.2.2 단순하지만 더 굵직한 스코프로 정의하기

*"굵직한 스코프는 컨슈머에게 여러 목표에 대한 권한을 적절한 수준에서 한 번에 제공하는 일종의 지름길이다."*



#### 8.2.3 스코프 전략 선택하기

#### 8.2.4 API 명세 포맷으로 스코프 정의하기

생략



---

### 8.3 접근 제어를 고려한 설계

호텔을 예로들면 투숙객들은 카드키를 통해 자신의 객실을 들어갈 수 있으며 다른 객실은 접근할 수 없다. 관리자는 들어갈 수 있을 것이다. 하지만 좀 더 나누면 특정 층에 대한 관리 권한만 부여할 수도 있다.

API 세계에서도 이러한 정제된 접근 제어가 존재한다.



#### 8.3.1 접근 제어에 필요한 데이터 이해하기

`GET /accounts` API는 각 사용자에 맞게 계좌 정보를 줘야할 것이다.`?uesrId=xxxx` 처럼 쿼리 스트링을 넘기지 않아도 해당 동작이 이루어져야한다. 어떻게 이게 가능할까?

이는 액세스 토큰 속에 다음과 같은 데이터가 있어야하는 표준이 있기 때문이다.

1. 사용자 ID
2. 클라이언트 ID
3. 허용된 스코프

이 데이터를 통해 내부 구현 개발자가 필터링해서 전달하는 것이다.



#### 8.3.2 필요에 따른 디자인 조정

생략



---

### 8.4 민감 요소의 취급

API 디자이너에게 가장 중요한 주제이다. API는 데이터와 가능한 행위를 외부로 노출하기 때문에 민감한 데이터가 관리되어야한다.



#### 8.4.1 민감한 데이터 취급하기

계좌 목록 조회 시 카드 정보(카드 번호, csv, 소유자, 유효기간 이름) 등등이 내려와 타인이 해당 카드에 대한 정보를 통해 인출 할 수 있는 위험이 있다. 



이러한 민감한 데이터를 취급하는 방법

1. 필수 요소가 아니면 제거
   - 카드 번호를 제거하면 유효 기간은 더 이상 민감한 데이터가 아니게 된다.
2. 민감하지 않은 형태로 변경
   - 카드 번호(2304-3029-3493)를 맨 뒤 4자리로만(3493) 제공한다.
   - 월 평균 결제액 (231만원)은 vip라는 플래그 값으로 바꾼다.
3. 민감한 데이터면 새로운 식별자로 만든다
   - 카드 번호(2304-3029-3493)를 새로운 식별자인 (c4dfs314)로 변경한다.
4. 민감한 데이터가 정말 필요하고 암호화가 충분하지 않다면 민감한 정보 자체를 암호화한다.



#### 8.4.2 민감한 목표 취급하기

민감한 데이터에 접근할 수 있는 권한을 확실하게 통제하기 위해 다음의 절차를 거치자.

1. 다른 API를 이용
2. 스코프 기반 제어
3. 권한 기반 제어
4. 2, 3을 조합하여 제어



#### 8.4.3 안전한 에러 피드백 디자인하기

보안을 위한 새로운 에러 피드백이 필요하다.

- 401 Unauthorized
  - 인증 정보가 잘못되었거나 없음
- 403 Forbidden
  - 유효하지 않은 스코프
- 403 Forbidden 또는 404 Not Found
  - 유효하지 않은 권한

> ⚠️ 주의
>
> 카드에 접근 권한이 없어 `403 Forbidden` 에러 코드와 함께 `해당 카드에 접근 권한이 없습니다.` 라는 에러 메시지를 던진다. 단순하게 보면 문제가 없어보이지만, 암시적으로 해당 카드가 존재한다는 것을 알려주기 때문에 `404 Not Found` 코드와 함께 `해당 카드가 존재하지 않습니다.`  정도로 제공하는게 좋다.



#### 8.4.4 아키텍처와 프로토콜 이슈 식별하기

경로나 파라미터에 로그로 남을 우려가 있는 민감한 정보는 포함하지 않도록 신중해야한다.



다음과 같은 상황에서는 민감한 데이터가 남을 수 있다.

- 내부 로드 밸런서 프록시에서는 민감한 데이터를 제거하고 로깅
- 외부 인터넷 접속 프록시에서는 모두 저장



또한 GET 요청에 의해 남을 수도 있기 때문에 POST로 바꾼 후 바디로 넘기는 편이 좋다.

1. GET /accounts?customerLastName=Yun
2. POST /accounts/search