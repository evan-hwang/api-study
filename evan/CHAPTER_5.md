# 2부 사용하기 좋은 API 디자인

*"사용하기 어려운  API에게 가치란 없습니다."*



## 5. 직관적인 API 디자인하기

이 장에서 다루는 내용

- 컨셉에 맞는 직관적 표현 만들기
- 관련된 에러의 성공 피드백 식별하기
- 효율적인 사용 흐름 디자인하기

사람들은 API의 사용성을 기대한다. 이 장에서는 가상의 은행을 예시로 API를 만들어볼 것이다.



### 5.1 직관적인 표현

*"API 명세는 사용자에게 직관적인 표현이어야한다."*



내부의 복잡성을 감추는 것 뿐 아니라 사용자에게 노출되는 다음의 요소들은 API의 사용성에 큰 영향을 미친다.

- 이름
- 데이터 타입 및 포맷
- 데이터 관련 의사결정



#### 5.1.1 명확한 이름 정하기

*"이름은 반드시 컨슈머 입장에서 의미있는 것으로 정해야한다."*



은행 API는 계좌에 초과 인출 제한 기능 옵션이 활성화되었는지 비활성화 되었는지에 대한 정보를 제공해야한다. 

이에 대한 키로 `bkAccOverProFtActBln`를 설정하게 되었는데, 이는 딱 봐도 컨슈머가 이해하기는 너무 어렵다.


이를 컨슈머가 이해하기 쉽도록 다음의 절차를 통해 줄여보자.

1. `bankAccountOverdraftProtectionFeatureActiveBln`
   - 약어를 사용하지말자. (하지만 max나 min처럼 일반적으로 받아들여지는 약어는 괜찮다.)
2. `bankAccountOverdraftProtectionFeature`
   - 내부 코딩 규칙을 노출하지말자. 
   - 해당 값이 Boolean 인지는 내부 로직이고 문서를 통해서도 드러낼 수 있다.
3. `bankAccountOverdraftProtection`
   - API 문서를 통해 알 수 있는 정보는 배제한다.
   - 은행 계좌 재산/서비스라는 의미는 문서의 설명으로 표현 가능하다.
4. `overdraftProtection`
   - 도메인에 종속적인 당연한 것들은 배제한다.
   - 이미 bankAccount에 종속된 API이다.



#### 5.1.2 사용하기 쉬운 데이터 타입과 포맷 정하기

*"API 응답의 데이터 타입과 포맷은 반드시 인간 중심적이어야한다."*



예를 들어

- 날짜

  - 불편한 포맷 : 1423425300
  - 편한 포맷 : "2015-02-07"

- 타입

  - 불편한 포맷 : 1
  - 편한 포맷 : "checking"

  

> ❓ 타임스탬프를 넘겨야하는 경우가 있는가?
>
> 사내 서비스에서는 클라이언트가 현재 로컬 위치에 따라 타임스탬프 값을 변경해서 사용하도록 하고 있다. 이를 편의성을 포함하는 포맷으로 해당 기능을 잃지 않으면서 넘기는 방법이 있을까?



#### 5.1.3 바로 사용할 수 있는 데이터 선택하기

*"컨슈머가 바로 사용할 수 있는 데이터를 제공하자"*



예를 들어

- `createDate` 대신 계좌가 개설 후 몇년이 지난지만 알면되므로 `yearsOpen` 으로 전달
- `balance` 로 잔고만 전달하는 대신 `currency` 를 포함하여 통화 정보도 알려주기



### 5.2 직관적인 상호작용

*"컨슈머가 쉽게 입력하고 유의미한 피드백을 받도록 하자. (꼭 성공이라는 피드백이 아니어도)"*



아래에서 **은행 송금 API**를 다음의 스텝을 통해 직관적인 상호작용하도록 만들어보자.

- 직관적 입력 제공
- 유용한 성공 피드백 반환
- 발생 가능한 모든 에러에 대한 유용한 피드백 반환



#### 5.2.1 직관적인 입력 요청하기

직관적인 입력에는 다음의 요소가 있다.

1. 명확한 이름을 사용한다.
2. 데이터 타입과 포맷은 이해하기 쉬워야한다.
3. 컨슈머가 입력하기 쉬운 데이터여야한다.



즉시 이체, 예약 이체, 자동 이체에 대한 API입력이 다음과 같다고 가정하고 해석해보자. 

```json
{
  "src": "9abksdkfskdf-sdkfkicsdkfk-dkfsdkfsdif",
  "dst": "dkfdkvisd934-asdsdkfksdkc-349dfakdkfk",
  "amt": 342.7,
  "dte": 1934829340,
  "typ": 3,
  "edt": 1993903993,
  "frq": 2
}
```



해석이 될리가 없다. 이를 고쳐보도록 하자.

1. 명확한 이름과 이해하기 쉬운 데이터 포맷으로 변경

   ```json
   {
     "source": "9abksdkfskdf-sdkfkicsdkfk-dkfsdkfsdif",
     "destination": "dkfdkvisd934-asdsdkfksdkc-349dfakdkfk",
     "amount": 342.7,
     "date": "2030-06-09",
     "type": "recurring",
     "endDate": "2031-06-09",
     "frequency": "monthly"
   }
   ```
   
   - 약어 제거
   - 날짜 포맷 변경
   - enum 데이터 문자열로 변경



2. 최소화되고 사용자가 입력하기 쉬운 데이터

   ```json
   {
     "source": "1002-302-50394",
     "destination": "1002-403-530432",
     "amount": 342.7,
     "date": "2030-06-09",
     "occurrences": 12,
     "frequency": "monthly"
   }
   ```

   - UUID 대신 계좌번호 사용
   - endDate 계산보다 입금 횟수 입력



자 훨씬 직관적인 입력으로 변경되었다.



#### 5.2.2 발생 가능한 모든 에러 피드백 식별하기

*"컨슈머가 꼭 처리해야할 문제에 대한 에러 피드백만 식별해야한다."*



발생할 수 있는 모든 에러를 식별해야한다.

1. 입력 에러 : 규격에 맞지 않은 입력
2. 기능 에러 : 비지니스 규칙에 의해 기능 실행 불가
3. 서버 에러 : 데이터베이스 서버 장애나 구현 버그로 인한 서버 내부 에러



#### 5.2.3 유용한 에러 피드백 반환하기

*"에러 피드백은 컨슈머가 무엇인 문제인지 알려주어 곧바로 해결할 수 있는데 도움이 되는 정보를 제공해야한다."*



백엔드 서버에서는 컨슈머에게 전달할 수 있는 HTTP 상태 코드가 있다. 상태코드를 적절하게 전달해야한다.

| 유즈 케이스        | 사용 예                                                  | HTTP 상태 코드            |
| ------------------ | -------------------------------------------------------- | ------------------------- |
| 잘못된 파라미터    | GET /accounts/123 - 리퀘스트 존재하지 않는 계좌번호 입력 | 404 Not Found             |
| 필수 속성 누락     | amount 누락                                              | 400 Bad Request           |
| 잘못된 데이터 타입 | "startDate": 123423034                                   | 400 Bad Request           |
| 기능적 에러        | 금액이 소비 한도 초과                                    | 403 Forbidden             |
| 기능적 에러        | 보내는 계좌에서 받는 계좌로의 이체가 금지됨              | 403 Forbidden             |
| 기능적 에러        | 지난 5분 이내에 동일한 송금이 발생한 전력이 있음         | 409 Conflict              |
| 서버 에러          | 구현에 버그가 숨겨져 있음                                | 500 Internal Server Error |



또한 응답 바디에도 상세한 에러 설명이 필요하다.

```json
{
  "source": "firstname",
  "path": "$.owners[0].firstname",
  "type": "MISSING_MANDATORY_PROPERTY",
  "message": "Firstname is mandotory"
}
```



#### 5.2.4 철저한 에러 피드백 반환하기

*"하나의 요청에서 발생할 수 있는 모든 에러에 대한 피드백을 한번에 주는 것이 좋다."*



#### 5.2.5 유용한 성공 피드백 반환하기

*"성공 피드백 또한 단순히 리퀘스트가 전달되었음을 인지하는 것 이상의 정보가 필요하다."*





### 5.3 직관적인 흐름

#### 5.3.1 직관적인 목표 연쇄 만들기

어떠한 목표를 이루기 위해 여러 스텝의 API가 필요할 수 있다. 

각 스텝의 API가 연쇄되는 특성을 가진다면 스텝 별로 요청과 응답을 통합할 수 있다.



#### 5.3.2 에러 방지

특정 스텝의 에러를 이전 스텝의 응답으로 필터링해서 방지할 수 있다. 

예를 들어 받을 수 있는 계좌 목록에서 보내는 계좌에 대한 차단 여부를 미리 판단해서 전달해주면 송금 시에 차단 여부를 판단하지 않아도 된다.



#### 5.3.3 목표 통합

직관적인 흐름을 제공하거나 에러 방지를 위해 목표 흐름은 목표들의 통합으로 단순화 할 수 있으나, 이는 컨슈머가 납득할 수 있는 경우에만 시도해야한다.



#### 5.3.4 상태가 없는 흐름 디자인하기

흐름을 통합하는 과정에서 각 API는 상태를 통해 이루어지면 안된다.

> ✏️ REST 제약사항 : 상태 없음 (Statelessness)
>
> 리퀘스트 사이에 세션 등을 통해 저장하는 컨텍스트가 존재하면안된다. 리퀘스트는 오직 리퀘스트가 제공하는 정보를 통해서만 처리되어야한다. 



## 요약

- 어떠한 표현이건 사람과 프로그램이 쉽게 이해할 수 있어야한다.
- 어떠한 표현이건 최대한 유익한 정보를 포함해야한다.
- 에러 피드백은 반드시 이해하고 문제를 조치하는데 충분한 요소들을 제공해야 한다.
- 성공 피드백은 반드시 무엇이 완료되었는지 설명해 주어야한다.
- 에러 방지를 위해 데이터나 새로운 목표를 추가하여 목표 흐름을 최적화 할 수 있다.
- 목표 흐름은 목표들의 통합으로 단순화 할 수 있으나, 이는 기능적 관점에서 납득할 수 있는 경우에만 시도해야한다.